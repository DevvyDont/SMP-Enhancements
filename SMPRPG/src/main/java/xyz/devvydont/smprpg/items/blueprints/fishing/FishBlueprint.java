package xyz.devvydont.smprpg.items.blueprints.fishing;

import net.kyori.adventure.text.Component;
import org.apache.commons.lang3.StringUtils;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;
import xyz.devvydont.smprpg.SMPRPG;
import xyz.devvydont.smprpg.items.CustomItemType;
import xyz.devvydont.smprpg.items.ItemClassification;
import xyz.devvydont.smprpg.items.ItemRarity;
import xyz.devvydont.smprpg.items.base.CustomItemBlueprint;
import xyz.devvydont.smprpg.items.interfaces.IHeaderDescribable;
import xyz.devvydont.smprpg.items.interfaces.IModelOverridden;
import xyz.devvydont.smprpg.items.interfaces.ISellable;
import xyz.devvydont.smprpg.services.ItemService;
import xyz.devvydont.smprpg.util.formatting.Symbols;
import xyz.devvydont.smprpg.util.persistence.PDCAdapters;
import xyz.devvydont.smprpg.util.persistence.KeyStore;
import xyz.devvydont.smprpg.util.rng.WeightedSelector;

import java.util.List;
import java.util.Map;

import static net.kyori.adventure.text.format.NamedTextColor.YELLOW;
import static xyz.devvydont.smprpg.util.formatting.ComponentUtils.create;
import static xyz.devvydont.smprpg.util.formatting.ComponentUtils.merge;

/**
 * Represents a blueprint for a basic fish that you can fish up. Can come in any rarity from COMMON -> LEGENDARY.
 * Better quality fish have better benefits.
 */
public class FishBlueprint extends CustomItemBlueprint implements IModelOverridden, IHeaderDescribable, ISellable {

    /**
     * Randomly fished items are randomly assigned rarities.
     */
    public final static Map<ItemRarity, Integer> DEFAULT_RARITY_WEIGHTS = Map.of(
            ItemRarity.COMMON,   45,
            ItemRarity.UNCOMMON, 25,
            ItemRarity.RARE,     15,
            ItemRarity.EPIC,      10,
            ItemRarity.LEGENDARY, 5
    );

    /**
     * Gets the probability that a fish can exist with a certain rarity.
     * @param rarity The rarity to query.
     * @return The probability that it had when generating with this rarity.
     */
    public static double probability(ItemRarity rarity) {
        var selector = new WeightedSelector<ItemRarity>();
        for (var entry : DEFAULT_RARITY_WEIGHTS.entrySet())
            selector.add(entry.getKey(), entry.getValue());
        return DEFAULT_RARITY_WEIGHTS.getOrDefault(rarity, 0) / selector.getTotalWeight();
    }

    /**
     * Returns a fresh instance of an item that is generated by the {@link FishBlueprint} blueprint.
     * Allows you to specify a rarity to generate the item with. Useful for recipes that require a specific rarity
     * in order to be a recipe member.
     * @param type The custom item type. Preferably a type of fish. If a non-fish is passed in, this will seemingly do nothing.
     * @param rarity The desired rarity of the fish.
     * @return A new item that conforms to this blueprint.
     */
    public static ItemStack of(CustomItemType type, ItemRarity rarity) {
        var item = ItemService.generate(type);
        if (!(ItemService.blueprint(item) instanceof FishBlueprint blueprint)) {
            SMPRPG.getInstance().getLogger().warning("Blueprint for " + type + " is not a FishBlueprint! This is not intended behavior.");
            return item;
        }
        blueprint.setRarity(item, rarity);
        return item;
    }

    public FishBlueprint(ItemService itemService, CustomItemType type) {
        super(itemService, type);
    }

    @Override
    public List<Component> getHeader(ItemStack itemStack) {
        return List.of(
                merge(create("Quality: "), create(StringUtils.repeat(Symbols.ENCLOSED_STAR, (getRarity(itemStack).ordinal()+1)), YELLOW))
        );
    }

    /**
     * Because we don't want fish to interact with furnaces, all custom fish should be clownfish items under the hood.
     * We can however overwrite what the fish looks like here. If we don't define a material, we are going to assume
     * we want the item to display as defined in {@link CustomItemType}.
     * @return The material texture override.
     */
    @Override
    public Material getDisplayMaterial() {
        return switch (this.getCustomItemType()) {
            case COD -> Material.COD;
            case SALMON, BLISTERFISH -> Material.SALMON;
            case PUFFERFISH, VOIDFIN -> Material.PUFFERFISH;
            case CLOWNFISH -> Material.TROPICAL_FISH;
            default -> this.getDisplayMaterial();
        };
    }

    /**
     * Get the base worth of this fish before applying a rarity modifier on it.
     * This essentially maps the COMMON worth of this item.
     * @return The base worth.
     */
    public int getBaseWorth() {
        return switch (this.getCustomItemType()) {
            case SALMON -> 15;
            case PUFFERFISH -> 25;
            case CLOWNFISH -> 100;
            case BLISTERFISH -> 125;
            case VOIDFIN -> 150;
            default -> 10;
        };
    }

    /**
     * Fish worth is a bit more complex than a normal item due to the possibilities we have.
     * Take into consideration the rarity and type of fish.
     * @param item The item that can be sold.
     * @return The worth.
     */
    @Override
    public int getWorth(ItemStack item) {
        var rarityFactor = (this.getRarity(item).ordinal() + 1);
        var base = this.getBaseWorth();
        return (int) (Math.pow(rarityFactor, rarityFactor) * base);
    }

    @Override
    public ItemClassification getItemClassification() {
        return ItemClassification.CONSUMABLE;
    }

    /**
     * The rarity of a fish is actually stored in the PDC since it was rolled when it was generated!
     * @param item The fish item.
     * @return The rarity this item should be.
     */
    @Override
    public ItemRarity getRarity(ItemStack item) {
        return item.getPersistentDataContainer().getOrDefault(KeyStore.ITEM_RARITY_OVERRIDE, PDCAdapters.RARITY, getDefaultRarity());
    }

    /**
     * Fish have a special function to set the rarity. This will also trigger an item update.
     * @param item The fish item.
     * @param rarity The new rarity to set this fish to.
     */
    public void setRarity(ItemStack item, ItemRarity rarity) {
        // Update internal storage, then trigger an update.
        item.editPersistentDataContainer(pdc -> pdc.set(KeyStore.ITEM_RARITY_OVERRIDE, PDCAdapters.RARITY, rarity));
        this.updateItemData(item);
    }

    /**
     * Picks a random rarity that should assumingly be applied to this fish item.
     * Follows a simple weighted rarity system, meaning you get lower rarities more often.
     * @return A new randomly picked rarity.
     */
    public ItemRarity pickRandomRarity() {
        var selector = new WeightedSelector<ItemRarity>();
        for (var entry : DEFAULT_RARITY_WEIGHTS.entrySet())
            selector.add(entry.getKey(), entry.getValue());
        return selector.roll().Element();
    }
}
